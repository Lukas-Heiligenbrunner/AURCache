//! `SeaORM` Entity. Generated by sea-orm-codegen 0.11.2

use std::str::FromStr;
use rocket::serde::Serialize;
use sea_orm::entity::prelude::*;
use serde::Deserialize;
use utoipa::ToSchema;


#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "type")] // the JSON field that acts as the tag
pub enum SourceData {
    #[serde(rename = "aur")]
    Aur {},
    #[serde(rename = "git")]
    Git {
        url: String,
        r#ref: String,
    },
    #[serde(rename = "upload")]
    Upload {
        archive: Vec<u8>,
    },
}

impl FromStr for SourceData {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let value: Self = serde_json::from_str(s)?;
        Ok(value)
    }
}

impl Default for SourceType {
    fn default() -> Self {
        SourceType::Aur
    }
}

#[derive(
    Clone, Debug, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize, ToSchema
)]
#[sea_orm(rs_type = "String", db_type = "Text")]
pub enum SourceType {
    #[sea_orm(string_value = "aur")]
    Aur,
    #[sea_orm(string_value = "git")]
    Git,
    #[sea_orm(string_value = "upload")]
    Upload,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, ToSchema)]
#[sea_orm(table_name = "packages")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    pub status: i32,
    pub out_of_date: i32,
    pub version: Option<String>,
    pub latest_aur_version: Option<String>,
    pub latest_build: Option<i32>,
    pub build_flags: String,
    pub platforms: String,
    pub source_type: SourceType,
    pub source_data: String,
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::builds::Entity")]
    Builds,
    #[sea_orm(
        belongs_to = "super::builds::Entity",
        from = "Column::LatestBuild",
        to = "super::builds::Column::Id"
    )]
    LatestBuild,
}

impl Related<super::builds::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Builds.def()
    }
}

impl Related<super::files::Entity> for Entity {
    fn to() -> RelationDef {
        super::packages_files::Relation::Files.def()
    }

    fn via() -> Option<RelationDef> {
        Some(super::packages_files::Relation::Packages.def())
    }
}
